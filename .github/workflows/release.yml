name: Semantic Release

on:
    push:
        branches: [main]

permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
        version: ${{ steps.get_version.outputs.version }}
    steps:
      # Ã‰tape 1: GÃ©nÃ¨re un token d'authentification depuis une GitHub App
      - name: Generate App Token
        id: get_token  # ID pour rÃ©fÃ©rencer les outputs de cette Ã©tape
        uses: actions/create-github-app-token@v2  # Action officielle pour crÃ©er un token
        with:
          app-id: ${{ secrets.APP_ID }}           # ID de l'application (stockÃ© dans les secrets)
          private-key: ${{ secrets.PRIVATE_KEY }} # ClÃ© privÃ©e de l'app (stockÃ©e dans les secrets)

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          cache-dependency-glob: "uv.lock"

      - name: Install dependencies
        run: uv sync

      # Ã‰tape 4: Installe Python Semantic Release comme outil
      - name: Install Python Semantic Release
        run: |
          # uv tool install : Installe un outil Python en isolation
          # python-semantic-release : Outil pour versionning sÃ©mantique automatique
          uv tool install python-semantic-release

      # Ã‰tape 5: GÃ©nÃ¨re une nouvelle version et publie la release
      - name: Semantic Versioning
        id: semantic
        env:
          # Token nÃ©cessaire pour crÃ©er des releases sur GitHub
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          GH_TOKEN: ${{ steps.get_token.outputs.token }}
        run: |
          # Configure l'identitÃ© Git pour les commits automatiques
          git config user.name "victor-four[bot]"
          git config user.email "victor-four[bot]@users.noreply.github.com"

          # uv run : ExÃ©cute la commande dans l'environnement de l'outil installÃ©
          # version --changelog : DÃ©termine la nouvelle version et met Ã  jour le changelog
          uv run semantic-release version --changelog

          # publish : CrÃ©e le tag Git et la release GitHub (uniquement sur main)
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "ðŸ“¦ Creating GitHub Release (main branch)"
            uv run semantic-release publish
          else
            echo "â­ï¸ Skipping GitHub Release (develop branch - pre-release only)"
            # Sur develop, on push juste le tag Git sans crÃ©er de GitHub Release
            git push --follow-tags origin HEAD
          fi

      # Ã‰tape 6: RÃ©cupÃ¨re la version crÃ©Ã©e pour l'exposer aux autres jobs
      - name: Get Version
        id: get_version
        run: |
          # RÃ©cupÃ¨re le dernier tag Git (qui correspond Ã  la version crÃ©Ã©e)
          VERSION=$(git describe --tags --abbrev=0)
          # Exporte la version dans les outputs du job
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  build:
    runs-on: ubuntu-latest
    needs: release

    steps:
      # Build and push Docker image
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.release.outputs.version }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
